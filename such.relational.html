<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>such.relational documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Suchwow 5.1.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>such</span></div></div></li><li class="depth-2 branch"><a href="such.better-doc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>better-doc</span></div></a></li><li class="depth-2 branch"><a href="such.casts.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>casts</span></div></a></li><li class="depth-2 branch"><a href="such.control-flow.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>control-flow</span></div></a></li><li class="depth-2 branch"><a href="such.doc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>doc</span></div></a></li><li class="depth-2 branch"><a href="such.environment.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>environment</span></div></a></li><li class="depth-2 branch"><a href="such.function-makers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>function-makers</span></div></a></li><li class="depth-2 branch"><a href="such.immigration.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>immigration</span></div></a></li><li class="depth-2 branch"><a href="such.imperfection.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>imperfection</span></div></a></li><li class="depth-2 branch"><a href="such.maps.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>maps</span></div></a></li><li class="depth-2 branch"><a href="such.metadata.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>metadata</span></div></a></li><li class="depth-2 branch"><a href="such.ns.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ns</span></div></a></li><li class="depth-2 branch"><a href="such.ns-state.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ns-state</span></div></a></li><li class="depth-2 branch"><a href="such.random.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>random</span></div></a></li><li class="depth-2 branch"><a href="such.readable.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>readable</span></div></a></li><li class="depth-2 branch current"><a href="such.relational.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>relational</span></div></a></li><li class="depth-2 branch"><a href="such.sequences.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sequences</span></div></a></li><li class="depth-2 branch"><a href="such.shorthand.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>shorthand</span></div></a></li><li class="depth-2 branch"><a href="such.symbols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>symbols</span></div></a></li><li class="depth-2 branch"><a href="such.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2 branch"><a href="such.vars.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vars</span></div></a></li><li class="depth-2 branch"><a href="such.versions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>versions</span></div></a></li><li class="depth-2 branch"><a href="such.wide-domains.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wide-domains</span></div></a></li><li class="depth-2"><a href="such.wrongness.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wrongness</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="such.relational.html#var-combined-index-on"><div class="inner"><span>combined-index-on</span></div></a></li><li class="depth-1"><a href="such.relational.html#var-extend-map"><div class="inner"><span>extend-map</span></div></a></li><li class="depth-1"><a href="such.relational.html#var-index"><div class="inner"><span>index</span></div></a></li><li class="depth-1"><a href="such.relational.html#var-index-select"><div class="inner"><span>index-select</span></div></a></li><li class="depth-1"><a href="such.relational.html#var-join"><div class="inner"><span>join</span></div></a></li><li class="depth-1"><a href="such.relational.html#var-one-to-many-index-on"><div class="inner"><span>one-to-many-index-on</span></div></a></li><li class="depth-1"><a href="such.relational.html#var-one-to-one-index-on"><div class="inner"><span>one-to-one-index-on</span></div></a></li><li class="depth-1"><a href="such.relational.html#var-project"><div class="inner"><span>project</span></div></a></li><li class="depth-1"><a href="such.relational.html#var-rename"><div class="inner"><span>rename</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">such.relational</h2><div class="doc"><div class="markdown"><p>This namespace provides two things: better documentation for relational functions in <code>clojure.set</code>, and an <em>experimental</em> set of functions for &ldquo;pre-joining&rdquo; relational tables for a more tree-structured or path-based lookup. See <a href="https://github.com/marick/suchwow/wiki/such.relational">the wiki</a> for more about the latter.</p><p>The API for the experimental functions may change without triggering a <a href="http://semver.org/">semver</a> major number change.</p></div></div><div class="public anchor" id="var-combined-index-on"><h3>combined-index-on</h3><div class="usage"><code>(combined-index-on starting-index foreign-key next-index ...)</code></div><div class="doc"><div class="markdown"><p>Create an index that maps directly from values in the starting index to values in the last of the list of indexes, following keys to move from index to index. Example:</p>
<pre><code> (let [index:countries-by-person-id (subject/combined-index-on index:rulership-by-person-id
                                                               :country_code
                                                               index:country-by-country-code)]
   (subject/index-select 1 :using index:countries-by-person-id :keys [:gdp])
   =&gt; [{:gdp 1690}])
</code></pre><p>(See <a href="https://github.com/marick/suchwow/wiki/such.relational">the wiki</a> for details.)</p></div></div><div class="src-link"><a href="https://github.com/marick/suchwow/blob/master/src/such/relational.clj#L363">view source</a></div></div><div class="public anchor" id="var-extend-map"><h3>extend-map</h3><div class="usage"><code>(extend-map kvs options)</code><code>(extend-map kvs k v &amp; rest)</code></div><div class="doc"><div class="markdown"><p>Add more key/value pairs to <code>kvs</code>. They are found by looking up values in a <a href="such.relational.html#var-one-to-one-index-on">one-to-one-index-on</a> or <a href="such.relational.html#var-one-to-many-index-on">one-to-many-index-on</a> index.</p><p>See <a href="https://github.com/marick/suchwow/wiki/such.relational">the wiki</a> for examples.</p><p>The <code>options</code> control what maps are returned and how they&rsquo;re merged into the original <code>kvs</code>. They may be given as N keys and values following the <code>kvs</code> argument (Smalltalk style) or as a single map. They are:</p>
<pre><code>:using &lt;index&gt;
  (required) The index to use.
:via &lt;key&gt;
  (required) A single foreign key or a sequence of them that is used to
  look up a map in the &lt;index&gt;.
:into &lt;key&gt;
  (optional, relevant only to a one-to-many map). Since a one-to-many map
  can&#39;t be merged into the `kvs`, it has to be added &quot;under&quot; (as the
  value of) a particular `key`.
:keys [key1 key2 key3 ...]
  (optional) Keys you&#39;re interested in (default is all of them)
:prefix &lt;prefix&gt;
  (optional) Prepend the given prefix to all the keys in the selected map.
  The prefix may be either a string or keyword. The resulting key will be
  of the same type (string or keyword) as the original.
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/suchwow/blob/master/src/such/relational.clj#L298">view source</a></div></div><div class="public anchor" id="var-index"><h3>index</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(index xrel ks)</code></div><div class="doc"><div class="markdown"><p><code>xrel</code> is a collection of maps; consider it the result of an SQL SELECT. <code>ks</code> is a collection of values assumed to be keys of the maps (think table columns). The result maps from particular key-value pairs to a set of all the maps in <code>xrel</code> that contain them.</p><p>Consider this <code>xrel</code>:</p>
<pre><code>(def xrel [ {:first &quot;Brian&quot; :order 1 :count 4}
            {:first &quot;Dawn&quot; :order 1 :count 6}
            {:first &quot;Paul&quot; :order 1 :count 5}
            {:first &quot;Sophie&quot; :order 2 :count 9} ])
</code></pre><p>Then <code>(index xrel [:order])</code> is:</p>
<pre><code>{{:order 1}
  #{{:first &quot;Paul&quot;, :order 1, :count 5}
    {:first &quot;Dawn&quot;, :order 1, :count 6}
    {:first &quot;Brian&quot;, :order 1, :count 4}},
  {:order 2}
    #{{:first &quot;Sophie&quot;, :order 2, :count 9}}}
</code></pre><p>&hellip; and <code>(index xrel [:order :count])</code> is:</p>
<pre><code>{{:order 1, :count 4}   #{ {:first &quot;Brian&quot;, :order 1, :count 4} },
 {:order 1, :count 6}   #{ {:first &quot;Dawn&quot;, :order 1, :count 6} },
 {:order 1, :count 5}   #{ {:first &quot;Paul&quot;, :order 1, :count 5} },
 {:order 2, :count 9}   #{ {:first &quot;Sophie&quot;, :order 2, :count 9} }}
</code></pre><p>If one of the <code>xrel</code> maps doesn&rsquo;t have an key, it is assigned to an index without that key. Consider this <code>xrel</code>:</p>
<pre><code>(def xrel [ {:a 1, :b 1} {:a 1} {:b 1} {:c 1}])
</code></pre><p>Then <code>(index xrel [:a b])</code> is:</p>
<pre><code>{  {:a 1, :b 1}    #{ {:a 1 :b 1} }
   {:a 1      }    #{ {:a 1} }
   {      :b 1}    #{ {:b 1} }
   {          }    #{ {:c 1} }})
</code></pre></div></div></div><div class="public anchor" id="var-index-select"><h3>index-select</h3><div class="usage"><code>(index-select key options)</code><code>(index-select key k v &amp; rest)</code></div><div class="doc"><div class="markdown"><p>Produce a map by looking a key up in an index.</p><p>See <a href="https://github.com/marick/suchwow/wiki/such.relational">the wiki</a> for examples.</p><p><code>key</code> is a unique or compound key that&rsquo;s been indexed with <a href="such.relational.html#var-one-to-one-index-on">one-to-one-index-on</a> or <a href="such.relational.html#var-one-to-many-index-on">one-to-many-index-on</a>. The <code>options</code> may be given as N keys and values following <code>key</code> (Smalltalk style) or as a single map. They are:</p>
<pre><code>:using &lt;index&gt;
  (required) The index to use.
:keys &lt;[keys...]&gt;
  (optional) Keys you&#39;re interested in (default is all of them)
:prefix &lt;prefix&gt;
  (optional) Prepend the given prefix to all the keys in the selected map.
  The prefix may be either a string or keyword. The resulting key will be
  of the same type (string or keyword) as the original.
</code></pre><p>The return value depends on the index. If it is <code>one-to-one</code>, a map is returned. If it is <code>one-to-many</code>, a vector of maps is returned.</p></div></div><div class="src-link"><a href="https://github.com/marick/suchwow/blob/master/src/such/relational.clj#L255">view source</a></div></div><div class="public anchor" id="var-join"><h3>join</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(join xrel yrel)</code><code>(join xrel yrel km)</code></div><div class="doc"><div class="markdown"><p><code>xrel</code> and <code>yrel</code> are collections of maps (think SQL SELECT). In the first form, produces the <a href="https://en.wikipedia.org/wiki/Join_%28SQL%29#Natural_join">natural join</a>. That is, it joins on the shared keys. In the following, <code>:b</code> is shared:</p>
<pre><code>  (def has-a-and-b [{:a 1, :b 2} {:a 2, :b 1} {:a 2, :b 2}])
  (def has-b-and-c [{:b 1, :c 2} {:b 2, :c 1} {:b 2, :c 2}])
  (join has-a-and-b has-b-and-c) =&gt; #{{:a 1, :b 2, :c 1}
                                      {:a 1, :b 2, :c 2}

                                      {:a 2, :b 1, :c 2}

                                      {:a 2, :b 2, :c 1}
                                      {:a 2, :b 2, :c 2}}}
</code></pre><p>Alternately, you can use a map to describe which left-hand-side keys should be considered the same as which right-hand-side keys. In the above case, the sharing could be made explicit with <code>(join
has-a-and-b has-b-and-c {:b :b})</code>.</p><p>A more likely example is one where the two relations have slightly different &ldquo;b&rdquo; keys, like this:</p>
<pre><code>  (def has-a-and-b [{:a 1, :b 2} {:a 2, :b 1} {:a 2, :b 2}])
  (def has-b-and-c [{:blike 1, :c 2} {:blike 2, :c 1} {:blike 2, :c 2}])
</code></pre><p>In such a case, the join would look like this:</p>
<pre><code>  (join has-a-and-b has-b-and-c {:b :blike}) =&gt;
                                    #{{:a 1, :b 2, :blike 2, :c 1}
                                      {:a 1, :b 2, :blike 2, :c 2}

                                      {:a 2, :b 1, :blike 1, :c 2}

                                      {:a 2, :b 2, :blike 2, :c 1}
                                      {:a 2, :b 2, :blike 2, :c 2}}
</code></pre><p>Notice that the <code>:b</code> and <code>:blike</code> keys are both included.</p><p>The join when there are no keys shared is the cross-product of the relations.</p>
<pre><code>  (clojure.set/join [{:a 1} {:a 2}] [{:b 1} {:b 2}])
  =&gt; #{{:a 1, :b 2} {:a 2, :b 1} {:a 1, :b 1} {:a 2, :b 2}}
</code></pre><p>The behavior when maps are missing keys is probably not something you should depend on.</p></div></div></div><div class="public anchor" id="var-one-to-many-index-on"><h3>one-to-many-index-on</h3><div class="usage"><code>(one-to-many-index-on table keyseq)</code></div><div class="doc"><div class="markdown"><p><code>table</code> should be a sequence of maps. <code>keyseq</code> is either a single value (corresponding to a traditional <code>:id</code> or <code>:pk</code> entry) or a sequence of values (corresponding to a compound key).</p><p>The resulting index provides fast retrieval of vectors of matching maps.</p>
<pre><code>(def index:traditional (one-to-many-index-on table :id))
(index-select 5 :using index:traditional :keys [:key-i-want]) ; a vector of maps

(def index:compound (one-to-many-index-on table [&quot;intkey&quot; &quot;strkey&quot;)))
(index-select [4 &quot;dawn&quot;] :using index:compound) ; a vector of maps
</code></pre><p>Keys may be either Clojure keywords or strings.</p></div></div><div class="src-link"><a href="https://github.com/marick/suchwow/blob/master/src/such/relational.clj#L233">view source</a></div></div><div class="public anchor" id="var-one-to-one-index-on"><h3>one-to-one-index-on</h3><div class="usage"><code>(one-to-one-index-on table keyseq)</code></div><div class="doc"><div class="markdown"><p><code>table</code> should be a sequence of maps. <code>keyseq</code> is either a single value (corresponding to a traditional <code>:id</code> or <code>:pk</code> entry) or a sequence of values (corresponding to a compound key).</p><p>The resulting index provides fast access to individual maps.</p>
<pre><code>(def index:traditional (one-to-one-index-on table :id))
(index-select 5 :using index:traditional :keys [:key1 :key2])

(def index:compound (one-to-one-index-on table [&quot;intkey&quot; &quot;strkey&quot;)))
(index-select [4 &quot;dawn&quot;] :using index:compound)
</code></pre><p>Note that keys need not be Clojure keywords.</p></div></div><div class="src-link"><a href="https://github.com/marick/suchwow/blob/master/src/such/relational.clj#L210">view source</a></div></div><div class="public anchor" id="var-project"><h3>project</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(project xrel ks)</code></div><div class="doc"><div class="markdown"><p><code>xrel</code> is a collection of maps (think SQL <code>SELECT *</code>). This function produces a set of maps, each of which contains only the keys in <code>ks</code>.</p>
<pre><code>(project [{:a 1, :b 1} {:a 2, :b 2}] [:b]) =&gt; #{{:b 1} {:b 2}}
</code></pre><p><code>project</code> differs from <code>(map #(select-keys % ks) ...)</code> in two ways:</p>
<ol>
  <li>It returns a set, rather than a lazy sequence.</li>
  <li>Any metadata on the original <code>xrel</code> is preserved. (It shares this behavior  with <a href="such.relational.html#var-rename">rename</a> but with no other relational functions.)</li>
</ol></div></div></div><div class="public anchor" id="var-rename"><h3>rename</h3><h4 class="added">added in 1.0</h4><div class="usage"><code>(rename xrel kmap)</code></div><div class="doc"><div class="markdown"><p><code>xrel</code> is a collection of maps. Transform each map according to the keys and values in <code>kmap</code>. Each map key that matches a <code>kmap</code> key is replaced with that <code>kmap</code> key&rsquo;s value.</p>
<pre><code> (rename [{:a 1, :b 2}] {:b :replacement}) =&gt; #{{:a 1, :replacement 2}}
</code></pre><p><code>rename</code> differs from <code>(map #(set/rename-keys % kmap) ...)</code> in two ways:</p>
<ol>
  <li>It returns a set, rather than a lazy sequence.</li>
  <li>Any metadata on the original <code>xrel</code> is preserved. (It shares this behavior with <a href="such.relational.html#var-project">project</a> but with no other relational functions.)</li>
</ol></div></div></div></div></body></html>